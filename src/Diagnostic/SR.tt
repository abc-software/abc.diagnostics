<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Security" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Runtime.Remoting.Messaging" #>
<#@ output extension=".Designer.cs" #><#

string candidate = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), Path.GetFileNameWithoutExtension(Host.TemplateFile) + ".resx");
string className = GetFriendlyName(Path.GetFileNameWithoutExtension(candidate));

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------

#if NET20 || NET30 || NET35 || NET40
namespace Diagnostic {
#else
namespace Abc.Diagnostics {
#endif
    using System;
    using System.Reflection;

	///<summary>
	/// Provides access to resource key names for the <#= className #> resource file.
	///</summary>
	[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
	[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
	internal class <#= className #> {
		private static global::System.Resources.ResourceManager resourceManager;
		private static global::System.Globalization.CultureInfo resourceCulture;

		[global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
		internal <#= className #>() {
		}

		/// <summary>
		/// Returns the cached ResourceManager instance used by this class.
		/// </summary>
		[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
		internal static global::System.Resources.ResourceManager ResourceManager {
			get {
				if (object.ReferenceEquals(resourceManager, null)) {
#if NET20 || NET30 || NET35 || NET40
					global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Diagnostic.<#= className #>", typeof(<#= className #>).Assembly);
#elif NETSTANDARD
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Abc.Diagnostics.<#= className #>", typeof(<#= className #>).GetTypeInfo().Assembly);
#else
					global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Abc.Diagnostics.<#= className #>", typeof(<#= className #>).Assembly);
#endif
					resourceManager = temp;
				}
				return resourceManager;
			}
		}
        
		/// <summary>
		/// Overrides the current thread's CurrentUICulture property for all
		/// resource lookups using this strongly typed resource class.
		/// </summary>
		[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
		internal static global::System.Globalization.CultureInfo Culture {
			get {
				return resourceCulture;
			}
			set {
				resourceCulture = value;
			}
		}

<# foreach(var resource in ReadResources(Host.ResolvePath(candidate))){ #>
		/// <summary>
		/// Looks up a localized string similar to <#= SecurityElement.Escape(resource.Item2) #>.
		/// </summary>
		internal static string <#= resource.Item1 #> {
			get {
				return ResourceManager.GetString("<#= resource.Item1 #>", resourceCulture);
			}
		}

<# } #>
	}
} 

<#+

public static readonly string NamespaceOverride = null; // leave NULL if you want the namespace to match the file location.

public static string GetNamespace()
{
	return !string.IsNullOrEmpty(NamespaceOverride) 
		? NamespaceOverride 
		: CallContext.LogicalGetData("NamespaceHint") as string;
}

public static IEnumerable<Tuple<string, string>> ReadResources(string resourcePath)
{
	return XElement.Load(resourcePath).Descendants("data").Select(x => new Tuple<string, string>(x.Attribute("name").Value, (string)x.Element("value")));
}

private static string GetFriendlyName(string path)
{
	var noExtension = new Regex(@"\.[^\.]+$");
	var strippedPath = noExtension.Replace(path, string.Empty);
	var unfriendlyPattern = new Regex("(?i)[^a-z0-9]+");
	return unfriendlyPattern.Replace(strippedPath, "_");
}
#>