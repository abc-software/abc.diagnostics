<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Security" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Runtime.Remoting.Messaging" #>
<#@ output extension=".Designer.cs" #><#

string candidate = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), Path.GetFileNameWithoutExtension(Host.TemplateFile) + ".resx");
string className = GetFriendlyName(Path.GetFileNameWithoutExtension(candidate));

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------

#if !NETSTANDARD
namespace <#= GetNamespace() #> {
    using System;

	///<summary>
	/// Provides access to resource key names for the <#= className #> resource file.
	///</summary>
	[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
	[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
	internal sealed class <#= className #> {
		private static global::System.Resources.ResourceManager resourceManager;
		private static global::System.Globalization.CultureInfo resourceCulture;

		[global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
		internal <#= className #>() {
		}

		/// <summary>
		/// Returns the cached ResourceManager instance used by this class.
		/// </summary>
		[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
		internal static global::System.Resources.ResourceManager ResourceManager {
			get {
				if (object.ReferenceEquals(resourceManager, null)) {
#if NET20 || NET30 || NET35 || NET40
					global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Diagnostic.Configuration.<#= className #>", typeof(<#= className #>).Assembly);
#else
					global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Abc.Diagnostics.Configuration.<#= className #>", typeof(<#= className #>).Assembly);
#endif
					resourceManager = temp;
				}
				return resourceManager;
			}
		}
        
		/// <summary>
		/// Overrides the current thread's CurrentUICulture property for all
		/// resource lookups using this strongly typed resource class.
		/// </summary>
		[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
		internal static global::System.Globalization.CultureInfo Culture {
			get {
				return resourceCulture;
			}
			set {
				resourceCulture = value;
			}
		}

<# foreach(var resource in ReadResources(Host.ResolvePath(candidate), 0)){ #>
		/// <summary>
		/// Looks up a localized string similar to <#= SecurityElement.Escape(resource.Item2) #>.
		/// </summary>
		internal static string <#= resource.Item1 #> {
			get {
				return ResourceManager.GetString("<#= resource.Item1 #>", resourceCulture);
			}
		}

<# } #>
<# foreach(var resource in ReadResources(Host.ResolvePath(candidate), 1)){ #>
        /// <summary>
        /// Formats a localized string similar to <#= SecurityElement.Escape(resource.Item2) #>.
        /// </summary>
        /// <param name="arg0">An object (0) to format.</param>
        /// <returns>A copy of format string in which the format items have been replaced by the String equivalent of the corresponding instances of Object in arguments.</returns>
        public static string <#= resource.Item1 #>Format(object arg0) {
            return string.Format(resourceCulture, <#= resource.Item1 #>, arg0);
        }

<# } #>
<# foreach(var resource in ReadResources(Host.ResolvePath(candidate), 2)){ #>
        /// <summary>
        /// Formats a localized string similar to <#= SecurityElement.Escape(resource.Item2) #>.
        /// </summary>
        /// <param name="arg0">An object (0) to format.</param>
        /// <param name="arg1">An object (1) to format.</param>
        /// <returns>A copy of format string in which the format items have been replaced by the String equivalent of the corresponding instances of Object in arguments.</returns>
        public static string <#= resource.Item1 #>Format(object arg0, object arg1) {
            return string.Format(resourceCulture, <#= resource.Item1 #>, arg0, arg1);
        }

<# } #>
	}
} 
#endif

<#+

public static readonly string NamespaceOverride = null; // leave NULL if you want the namespace to match the file location.

public static string GetNamespace()
{
	return !string.IsNullOrEmpty(NamespaceOverride) 
		? NamespaceOverride 
		: CallContext.LogicalGetData("NamespaceHint") as string;
}

public static IEnumerable<Tuple<string, string>> ReadResources(string resourcePath, int numberOfArguments)
{
	var resources = XElement.Load(resourcePath).Descendants("data").Select(x => new Tuple<string, string>(x.Attribute("name").Value, (string)x.Element("value")));
	if (numberOfArguments > 0) {
		return resources.Where(x => FormatValidator.Parse(x.Item2) == numberOfArguments);
	}

	return resources;
}

private static string GetFriendlyName(string path)
{
	var noExtension = new Regex(@"\.[^\.]+$");
	var strippedPath = noExtension.Replace(path, string.Empty);
	var unfriendlyPattern = new Regex("(?i)[^a-z0-9]+");
	return unfriendlyPattern.Replace(strippedPath, "_");
}

/// <summary>
/// String format validator.
/// </summary>
private static class FormatValidator {
    private const string FormatInvalidString = "Input string was not in a correct format.";
    private const string FormatIndexOutOfRange = "Index (zero based) must be greater than or equal to zero and less than the size of the argument list.";

    /// <summary>
    /// Parses the specified format.
    /// </summary>
    /// <param name="format">The format.</param>
    /// <returns>The parse result</returns>
    public static int Parse(string format) {
        if (null == format) {
            throw new ArgumentNullException("format");
        }

        char[] formatChars = format.ToCharArray(0, format.Length);
        int cursor = 0;
        char currChar = '\0';
        List<int> argumentIndexes = new List<int>();

        while (true) {
            int supplementaryCursor = cursor;
            while (cursor < formatChars.Length) {
                currChar = formatChars[cursor];
                cursor++;
                if (currChar == '}') {
                    if ((cursor < formatChars.Length) && (formatChars[cursor] == '}')) {
                        cursor++;
                    }
                    else {
                        FormatError();
                    }
                }

                if (currChar == '{') {
                    if ((cursor < formatChars.Length) && (formatChars[cursor] == '{')) {
                        cursor++;
                    }
                    else {
                        cursor--;
                        break;
                    }
                }

                formatChars[supplementaryCursor++] = currChar;
            }

            if (cursor == formatChars.Length) {
                // Checking the argument list
                argumentIndexes.Sort();

                for (int argumentIndex = 0; argumentIndex < argumentIndexes.Count; ++argumentIndex) {
                    if (argumentIndex != argumentIndexes[argumentIndex]) {
                        throw new FormatException(FormatIndexOutOfRange);
                    }
                }

                return argumentIndexes.Count;
            }

            // Checking the first index letter
            cursor++;
            if (((cursor == formatChars.Length) || ((currChar = formatChars[cursor]) < '0')) || (currChar > '9')) {
                FormatError();
            }

            // Getting the index
            int index = 0;
            do {
                index = ((index * 10) + currChar) - 0x30;
                cursor++;
                if (cursor == formatChars.Length) {
                    FormatError();
                }

                currChar = formatChars[cursor];
            }
            while (((currChar >= '0') && (currChar <= '9')) && (index < 0xf4240));

            // Storing the index
            if (!argumentIndexes.Contains(index)) {
                argumentIndexes.Add(index);
            }

            while ((cursor < formatChars.Length) && ((currChar = formatChars[cursor]) == ' ')) {
                cursor++;
            }

            // Getting the alignment
            int alignment = 0;
            if (currChar == ',') {
                cursor++;
                while ((cursor < formatChars.Length) && (formatChars[cursor] == ' ')) {
                    cursor++;
                }

                if (cursor == formatChars.Length) {
                    FormatError();
                }

                currChar = formatChars[cursor];
                if (currChar == '-') {
                    cursor++;
                    if (cursor == formatChars.Length) {
                        FormatError();
                    }

                    currChar = formatChars[cursor];
                }

                if ((currChar < '0') || (currChar > '9')) {
                    FormatError();
                }

                do {
                    alignment = ((alignment * 10) + currChar) - 0x30;
                    cursor++;
                    if (cursor == formatChars.Length) {
                        FormatError();
                    }

                    currChar = formatChars[cursor];
                }
                while (((currChar >= '0') && (currChar <= '9')) && (alignment < 0xf4240));
            }

            while ((cursor < formatChars.Length) && ((currChar = formatChars[cursor]) == ' ')) {
                cursor++;
            }

            // object obj1 = args[index];
            string formatString = null;
            if (currChar == ':') {
                cursor++;
                int formatStringBeginning = cursor;
                supplementaryCursor = cursor;
                while (true) {
                    if (cursor == formatChars.Length) {
                        FormatError();
                    }

                    currChar = formatChars[cursor];
                    cursor++;
                    if (currChar == '{') {
                        if ((cursor < formatChars.Length) && (formatChars[cursor] == '{')) {
                            cursor++;
                        }
                        else {
                            FormatError();
                        }
                    }
                    else if (currChar == '}') {
                        if ((cursor < formatChars.Length) && (formatChars[cursor] == '}')) {
                            cursor++;
                        }
                        else {
                            cursor--;
                            break;
                        }
                    }

                    formatChars[supplementaryCursor++] = currChar;
                }

                if (supplementaryCursor > formatStringBeginning) {
                    formatString = new string(formatChars, formatStringBeginning, supplementaryCursor - formatStringBeginning);
                }
            }

            if (currChar != '}') {
                FormatError();
            }

            cursor++;
        }
    }

    private static void FormatError() {
        throw new FormatException(FormatInvalidString);
    }
}
#>